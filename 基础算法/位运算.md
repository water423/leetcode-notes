## 位运算的相关技巧

1. 二进制表示中的最低位
   1. `n & (n-1)`移除最低位的1
      * 假设 n 的二进制表示为 (a10⋯0)2，其中 a 表示若干个高位，1 表示最低位的那个 1，0⋯00 表示后面的若干个 0，那么 n−1 的二进制表示为(a01⋯1)2，我们将 (a10⋯0)2与 (a01⋯1)2进行按位与运算，高位 a 不变，在这之后的所有位都会变为 0，这样我们就将最低位的那个 1 移除了。
   
   2. `n & (-n)`获取二进制表示中最低位的1
      * 假设 n 的二进制表示为 (a10⋯0)2 ，其中 a 表示若干个高位，1 表示最低位的那个 1，0⋯00 表示后面的若干个 0，那么 −n（原码取反再+1） 的二进制表示为：(a‘01⋯1)2+(1)2=(a’10⋯0)2，其中 a‘表示将 a 每一位取反。我们将 (a10⋯0)2  与 (a’10⋯0)2 进行按位与运算，高位全部变为 000，最低位的 1 以及之后的所有 0 不变，这样我们就获取了 n 二进制表示的最低位的 1。
   
   3. `n > 0 && (n & (n - 1)) == 0` 判断 n 是否是2的幂
   
   4. `n > 0 && (n & (n - 1)) == 0 && (n & 0xaaaaaaaa) == 0` 判断 n 是否是4的幂
   
      * 如果 n 是 4 的幂，那么 n 的二进制表示中有且仅有一个 1，并且这个 1 出现在从低位开始的第偶数个二进制位上（这是因为这个 1 后面必须有偶数个 0）。这里规定最低位为第 0 位，例如 n=16 时，nnn 的二进制表示为  (10000)2，唯一的 1 出现在第 4 个二进制位上，因此 n 是 4 的幂。由于题目保证了 n 是一个 32 位的有符号整数，因此我们可以构造一个整数 mask，它的所有偶数二进制位都是 0，所有奇数二进制位都是 1，将 n 和 mask进行按位与运算，如果结果为 0，说明 n 二进制表示中的 1 出现在偶数的位置，否则说明其出现在奇数的位置。mask的二进制表示为：mask=(10101010101010101010101010101010)2，将其表示成 16 进制的形式，mask=(AAAAAAAA)。
   
      `n > 0 && (n & (n - 1)) == 0 && n % 3 == 1`  判断 n 是否是4的幂（mod 3 一定为1）
   
   5. `n > 0 && 1162261467 % n == 0` 判断 n 是否是3的幂（1162261467 = 3 ^ 19 是int范围内最大的3的幂 一定存在倍数关系）
   
   6. 求a + b
   
      ```java
      public int getSum(int a, int b) {
          if(b == 0) return a;
          if(a == 0) return b;
          return getSum(a^b, (a&b)<<1);
      }
      ```
   
      



2. leetcode 260 只出现一次的元素III

   1. 题目：给你一个整数数组 `nums`，其中恰好有两个元素只出现一次，其余所有元素均出现两次。 找出只出现一次的那两个元素。你可以按 **任意顺序** 返回答案。你必须设计并实现线性时间复杂度的算法且仅使用常量额外空间来解决此问题。

   2. 范围：`2 <= nums.length <= 3 * 10`  `-231 <= nums[i] <= 231 - 1`

      ​              除两个只出现一次的整数外，`nums` 中的其他数字都出现两次

   3. 代码：

      ```java
      public int[] singleNumber(int[] nums) {
          int k = 0;
          for(int num : nums){ k ^= num; }
          //k = num1 ^ num2
          //k的最后一位为1的位置即num1 num2不同的位置
          //取其作为mask来将数组中的所有其他数都分为两类
          //则每一类均为 num1/num2 + 剩余的两两相同的数
          //转化为求唯一一个只出现一次的数
          int mask = k & (-k);
          int num1 = 0; int num2 = 0;
          for(int num : nums){
              //每一类中重复出现的数两两抵消之后剩余的就是结果
              //注意是按照 == mask 来划分而不是 == 1
              if((num & mask) == mask){ num1 ^= num; }
              else{ num2 ^= num; }
          }
          return new int[]{num1, num2};
      }
      ```

      