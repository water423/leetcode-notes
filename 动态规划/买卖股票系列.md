## 买卖股票的最佳时机系列相关问题

1. leetcode 121 买卖股票的最佳时机 （仅可以**买卖一次**）

   1. 题目：给定一个数组 `prices` ，它的第 `i` 个元素 `prices[i]` 表示一支给定股票第 `i` 天的价格。你只能选择 **某一天** 买入这只股票，并选择在 **未来的某一个不同的日子**卖出该股票。设计一个算法来计算你所能获取的最大利润。返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 `0` 。

   2. 范围：`1 <= prices.length <= 105`  `0 <= prices[i] <= 104`

   3. 思路：根据题意，每一天可以处于两个状态之中，一个是未持有股票（已经买入一次并且卖出一次状态），一个是持有股票状态（买入的股票），（还有一种是一次也没有买入股票状态，此状态一致保持值为0，与初始化相同，因此可以不考虑）。则本题对应的状态定义为 **$dp[i][0]$ 表示第 $i$ 天处于已经买入一次（持有股票）的状态时的最大利润，$dp[i][1]$ 表示已经处于买卖一次股票（不持有股票）的最大利润**，则状态转移方程如下：

      * $dp[i][0] = max(dp[i-1][0], -prices[i])$ 

        * 表示 和前一天一样保持持有状态 或 当天**第一次**买入（固定值）

      * $dp[i][1] = max(dp[i-1][1],dp[i-1][0]+prices[i])$

        *  表示 和前一天一样保持不持有状态 或 前一天持有当天卖出

        这里需要注意的是 对于买入操作其永远是选择最佳的时机进行买入（比如 对于 3 5 1则其最终仍然会选择在price为1的时候进行买入），卖出总是在最佳的时机进行卖出，因为 $dp[i-1][0]$ 总是会保持最佳的买入状态。则**此时的DP相当于不断在if条件中进行选择的过程，遇到更优的状态就选择否则就保持**，所以本题中需要保存两个状态（不断检测是否会出现更优的状态）。最终的结果只需要返回 $dp[nums.length-1][1]$ 即可（不需要再求 $max$ ，因为最好的状态是会一致保持的，并且一定是不持有股票的状态）。

   4. 代码：本题也可以直接使用一次遍历求min max来求解

      ```java
      public int maxProfit(int[] prices) {
          int[][] dp = new int[prices.length][2]; //也可以只定义dp[2]
          dp[0][0] = -prices[0];
          dp[0][1] = 0;
          for(int i = 1; i < prices.length; i++){
              dp[i][0] = Math.max(dp[i-1][0], -prices[i]);
              dp[i][1] = Math.max(dp[i-1][1], dp[i-1][0]+prices[i]);
          }
          return dp[prices.length-1][1];
      }
      ```

      

2. leetcode 122 买卖股票的最佳时机II （可以**买卖无数次**）

   1. 题目：给你一个整数数组 `prices` ，其中 `prices[i]` 表示某支股票第 `i` 天的价格。在每一天，你可以决定是否购买和/或出售股票。你在任何时候 **最多** 只能持有 **一股**股票。你也可以先购买，然后在 **同一天** 出售。返回 *你能获得的 **最大** 利润* 。

   2. 范围：`1 <= prices.length <= 3 * 104` `0 <= prices[i] <= 104`

   3. 思路：本题与第一题的差别仅仅是一个是只能买卖一次，而本题中可以买卖无数次，因此每次买入的时候是可以在此前已经买卖过几次获得的利润的基础上进行的，因此状态的定义和划分同上，状态转移方程如下：

      * $dp[i][0] = max(dp[i-1][0], dp[i-1][1]-prices[i])$ 表示 和前一天一样保持持有状态 或 当天买入
      * $dp[i][1] = max(dp[i-1][1],dp[i-1][0]+prices[i])$​ 表示 和前一天一样保持不持有状态 或 前一天持有当天卖出

      同样可以理解成不断对于最优状态的选择，即不断在低价的时刻买入在高价的时刻卖出。

   4. 代码：本题也可以使用贪心的思路进行，即对于相邻两天的股票价格求差值，并且买入所有的正值。

      ```java
      public int maxProfit(int[] prices) {
          int[] dp = new int[2];
          dp[0] = -prices[0];
          dp[1] = 0;
          for(int i = 1; i < prices.length; i++){
              int dp_0_before = dp[0];
              dp[0] = Math.max(dp[0], dp[1]-prices[i]);
              //此处的dp_0_before也可以直接换成dp[0]
              //可以被认为是同一天买入同一天卖出
              dp[1] = Math.max(dp[1], dp_0_before+prices[i]);   
          }
          return dp[1];
      }
      ```

      

3. leetcode123 买卖股票的最佳时机III （可以买卖两次，状态机DP）

   1. 题目：给定一个数组，它的第 `i` 个元素是一支给定的股票在第 `i` 天的价格。设计一个算法来计算你所能获取的最大利润。你最多可以完成 **两笔** 交易。**注意：**你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。

   2. 范围：`1 <= prices.length <= 105`  `0 <= prices[i] <= 105`

   3. 思路：

      * 思路1：买卖两次就相当于两个买卖一次，因此可以枚举切割点，对于前后两部分子数组进行买卖一次的操作
      * 思路2：类似于买卖一次的思路 ，买卖一次对应了2个状态定义，则买卖2次就对应了四个状态，分别是 处于买入一次的状态、处于买卖一次的状态、处于买卖一次后又买入的状态、处于买卖两次的状态。则同样进行推理，状态转移方程如下：
        * $dp[i][0] = max(dp[i-1][0], -prices[i])$
        * $dp[i][1] = max(dp[i-1][1], dp[i-1][0]+prices[i])$
        * $dp[i][2] = max(dp[i-1][2], dp[i-1][1]-prices[i])$
        * $dp[i][3] = max(dp[i-1][3], dp[i-1][2]+prices[i])$

   4. 代码：由于状态转移方程仅仅涉及两个相邻的日期之间，因此可以抽象为dp[4]或者仅仅用四个变量进行表示

      ```java
      public int maxProfit(int[] prices) {
          int n = prices.length;
          int buy1 = -prices[0], sell1 = 0;
          int buy2 = -prices[0], sell2 = 0;
          for (int i = 1; i < n; ++i) {
              buy1 = Math.max(buy1, -prices[i]);
              //这里直接使用buy1 因为可以直接视作当天买入当天卖出
              sell1 = Math.max(sell1, buy1 + prices[i]);
              buy2 = Math.max(buy2, sell1 - prices[i]);
              sell2 = Math.max(sell2, buy2 + prices[i]);
          }
          return sell2;
      }
      ```

      

4. leetcode188 买卖股票的最佳时机IV （可以买卖K次，状态机DP）

   1. 题目：给你一个整数数组 `prices` 和一个整数 `k` ，其中 `prices[i]` 是某支给定的股票在第 `i` 天的价格。设计一个算法来计算你所能获取的最大利润。你最多可以完成 `k` 笔交易。也就是说，你最多可以买 `k` 次，卖 `k` 次。**注意：**你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。

   2. 范围：`1 <= k <= 100`  `1 <= prices.length <= 1000`  `0 <= prices[i] <= 1000`

   3. 思路：类比上一题，将两次四个状态推广到k次2k个状态

   4. 代码：可以将数组先定义成二维的再抽象到一维

      ```java
      //方式1:视作在同一天可以买了又卖掉
      public int maxProfit(int k, int[] prices) {
          //在III的基础之上将两次推广到k次
          int[] dp = new int[2*k+1];
          //此处的初始化可以认为在同一天多次买卖
          for(int i = 1; i <= 2*k; i+=2){
              dp[i] = -prices[0];
          }
          for(int i = 1; i < prices.length; i++){
              for(int j = 1; j <= 2*k; j+=2){
                  //已经买卖k-1次又买入1次
                  dp[j] = Math.max(dp[j], dp[j-1]-prices[i]);   
                  //已经买卖k次
                  dp[j+1] = Math.max(dp[j+1], dp[j]+prices[i]); 
              } 
          }
          return dp[2*k] < 0 ? 0 : dp[2*k];
      }
      ```

      ```java
      //方式2:视作不能在同一天买了卖
      public int maxProfit(int k, int[] prices) {
          //在III的基础之上将两次推广到k次
          int[] dp = new int[2*k+1];
          dp[0] = 0;
          dp[1] = -prices[0];
          for(int i = 1; i < prices.length; i++){
              for(int j = 1; j <= 2*k; j+=2){
                  //已经买卖k-1次又买入1次
                  if(dp[j-1] != Integer.MIN_VALUE){
                      dp[j] = Math.max(dp[j], dp[j-1]-prices[i]);    
                  }
                  //已经买卖k次
                  if(dp[j] != Integer.MIN_VALUE){
                      dp[j+1] = Math.max(dp[j+1], dp[j]+prices[i]);  
                  }
              } 
          }
          return dp[2*k] < 0 ? 0 : dp[2*k];
      }
      ```

      

5. leetcode 309 买卖股票的最佳时机含冷冻期 （**状态机DP**）

   1. 题目：给定一个整数数组`prices`，其中第 `prices[i]` 表示第 `i` 天的股票价格 。设计一个算法计算出最大利润。在满足以下约束条件下，你可以尽可能地完成更多的交易（多次买卖一支股票）:卖出股票后，你无法在第二天买入股票 (即冷冻期为 1 天)。**注意：**你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。

   2. 范围：`1 <= prices.length <= 5000` `0 <= prices[i] <= 1000`

   3. 思路：状态机DP题首先需要划分状态，即每一天可能处于的状态，需要不重复不遗漏。**由于卖出股票会导致冷冻期，因此可以按照当天是否卖出股票来进行划分，状态划分如下**：

      * $dp[0]$ : 持有股票的状态（即已经买入了）
      * $dp[1]$ : 不持有股票的状态且不是当天卖出股票的（包含冷冻期）
      * $dp[2]$ : 不持有股票的状态且是当天卖出股票的/不可以买入股票

      属性均是当天的利润最大值。对应的状态转移如下：

      * 当天持有股票则可以是前一天就持有股票，或者前一天不持有股票且不是前一天卖出的（即今天不是冷冻期）

        * $ dp[0] = max( dp[0], dp[1]-prices[i] )$

      * 当天不持有股票且不是当天卖出的可以是前一天就处于这样的状态（今天不是冷冻期），或者是前一天卖出股票并处于未持有股票的状态（今天是冷冻期）

        * $dp[1] = max(dp[1], dp[2])$

      * 当天不持有股票且是当天卖出的则只能是前一天持有股票且在今天卖出一种情况

        * $dp[2] = dp[0]+prices[i]$

        此外，也可以按照冷冻期来进行状态划分，即持有股票（前一天已经持有股票或前一天处于未持有股票且不是冷冻期并在今天买入）、不持有股票且**后一天**将处于冷冻期（前一天持有股票并在今天卖出）、不持有股票且**后一天**不处于冷冻期（前一天不持有股票且后一天不处于冷冻期/处于冷冻期均可），但是这样理解比较费力，因为需要考虑**后一天**。

        或如果将状态抽象成 持有股票、当天卖出股票而不持有、当天未卖出股票而不持有、当天处于冷冻期（不可持续的状态）四个状态后可以发现后两个状态是可以合并的。

        最终返回的结果是最后一天不持有股票（当天卖出、处于冷冻期）均可。

   4. 代码：

      ```java
       public int maxProfit(int[] prices) {
          int[][] dp = new int[prices.length][3];
          dp[0][0] = -prices[0];
          dp[0][1] = 0;
          dp[0][2] = 0;
          for(int i = 1; i < prices.length; i++){
              dp[i][0] = Math.max(dp[i-1][0], dp[i-1][1]-prices[i]);
              dp[i][1] = Math.max(dp[i-1][1], dp[i-1][2]);
              dp[i][2] = dp[i-1][0] + prices[i];
          }
          return Math.max(dp[prices.length-1][1], dp[prices.length-1][2]);
      }
      ```

      

6. leetcode 714 买卖股票的最佳时机含手续费 

   1. 题目：给定一个整数数组 `prices`，其中 `prices[i]`表示第 `i` 天的股票价格 ；整数 `fee` 代表了交易股票的手续费用。

      你可以无限次地完成交易，但是你每笔交易都需要付手续费。如果你已经购买了一个股票，在卖出它之前你就不能再继续购买股票了。返回获得利润的最大值。**注意：**这里的一笔交易指买入持有并卖出股票的整个过程，每笔交易你只需要为支付一次手续费。

   2. 范围：`1 <= prices.length <= 5 * 104`  `1 <= prices[i] < 5 * 104` `0 <= fee < 5 * 104`

   3. 思路：与可以无数次购买股票相同，仅仅是在卖出股票时额外计算手续费

   4. 代码：

      ```java
      public int maxProfit(int[] prices, int fee) {
          int[][] dp = new int[prices.length][2];
          dp[0][0] = -prices[0];
          dp[0][1] = 0;
          for(int i = 1; i <= prices.length-1; i++){
              dp[i][0] = Math.max(dp[i-1][0], dp[i-1][1]-prices[i]);
              dp[i][1] = Math.max(dp[i-1][1], dp[i-1][0]+prices[i]-fee);
          }
          return dp[prices.length-1][1];
      
      }
      ```

      