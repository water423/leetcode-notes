## 树形DP

1. 常见题型与思路

   1. 题型：树形DP一般会比较明显地给出树的结构（如二叉树等），并且会涉及到父节点与相关子节点无法同时选择/父节点与子节点的状态会相互影响，从而在题目的限制条件下求最大值/最小值等。

   2. 思路：设定目的是**求以某个节点为根节点时在整个子树满足条件时的目标最大值/最小值等**，**从父节点和子节点的相互影响角度出发，判断每个节点一共会出现几个状态以及对于root节点这几个状态之间是如何转移的并影响目标值的，从而推导出状态转移方程。**树形DP的模版是在dfs的过程中，用子节点的dfs结果来计算父节点的值。

      

2. Leetcode 337 打家劫舍III **（树形DP）**

   1. 题目：小偷又发现了一个新的可行窃的地区。这个地区只有一个入口，我们称之为 `root` 。除了 `root` 之外，每栋房子有且只有一个“父“房子与之相连。一番侦察之后，聪明的小偷意识到“这个地方的所有房屋的排列类似于一棵二叉树”。 如果 **两个直接相连的房子在同一天晚上被打劫** ，房屋将自动报警。给定二叉树的 `root` 。返回 ***在不触动警报的情况下** ，小偷能够盗取的最高金额* 。

   2. 范围： 树的节点数在 `[1, 104]` 范围内；`0 <= Node.val <= 104`

   3. 思路：以子树为粒度进行分析，其根为root，dp[0]表示root不被偷时整个子树可以被偷的最大金额；dp[1]表示root被偷时整个子树可以被偷的最大金额，这两个值需要使用其子树的对应返回值进行计算，因此**树形DP存在于dfs对每个子树的过程中**。

      * $dp[0] = max(leftdp[0],leftdp[1]) + max(rightdp[0], rightdp[1])$
      * $dp[1] = leftdp[0] + leftdp[0] + value[root]$

   4. 代码：

      ```java
      public int rob(TreeNode root) {
          int[] res = dfs(root);
          return Math.max(res[0], res[1]);
      }
      
      public int[] dfs(TreeNode root){
          if(root == null){return new int[2];}  //递归返回条件
          //此处需要定义两个状态（抢劫root/不抢劫root）
          //而不是只返回可以抢夺的最大金额的原因是：
          //无法仅仅通过左右子树的最大金额和隐含的if条件语句推出结果
          int not_rob = 0;
          int do_rob = root.val;
          int[] l_res = dfs(root.left);
          int[] r_res = dfs(root.right);
          not_rob += Math.max(l_res[0], l_res[1]) + Math.max(r_res[0], r_res[1]);
          do_rob += l_res[0] + r_res[0];
          return new int[]{not_rob, do_rob};
      }
      ```



3. Leetcode 968 监控二叉树

   1. 题目：给定一个二叉树，我们在树的节点上安装摄像头。节点上的每个摄影头都可以监视**其父对象、自身及其直接子对象。**计算监控树的所有节点所需的最小摄像头数量。

   2. 范围：给定树的节点数的范围是 `[1, 1000]`；每个节点的值都是 0。

      1. 思路：根据题意，目标即为**求当以root为子树的根节点时整个子树均被监控需要的摄像头最小值**。对于每个节点，其状态可以分为三类：（1）当前节点自身装摄像头；（2）当前节点不装摄像头但是处于监控状态；（3）当前节点不装摄像头且未被监控。然而，由于目标是子树中所有节点均处理监控状态，因此（3）删除。其中，由于每个节点可以被父节点和子节点同时影响，因此，状态（2）可以细分成 **当前节点不装摄像头但是父节点装了摄像头、 当前节点不装摄像头但是其中一个子节点装了摄像头** 从而满足其处于监控状态。根据以上的状态定义和目标来推断状态转移（由子节点的状态及对应值来推断父节点）：

         * （1）若当前节点已经安装了摄像头，则子节点处于（1）安装了摄像头 （2）[1]未安装摄像头但父节点安装了摄像头；每个子节点对于这两种状态取最小值后相加，还需要加上当前节点安装的这一个摄像头。
         * （2）[1] 若当前节点不装摄像头但是父节点装了摄像头，则任意一个子节点应该处于 （1）安装摄像头 或 （2）[2]当前节点不装摄像头但是其中一个子节点装了摄像头 状态；每个子节点对于这两种状态取最小值后相加。
         * （2）[2]若当前节点不装摄像头但是其中一个子节点装了摄像头，则两个子节点应该为 [1] 一个处于（1）安装摄像头，另 一个处于（2）[2]未安装摄像头但子节点安装摄像头的状态，对于这两种情况将所有子节点结果求和后取最小值；**[2]两个都安装了摄像头。（由于无法判断每个子树在各个状态下的总体情况，因此不能认为两个都装的结果一定是大于一个装一个不装的，具体取决于树的结构）**

         则综合以上信息，将三个状态对应到当前节点的状态数组dp[3]中，可以写出如下的状态转移方程：

         * $dp[0] = min(dp_(left)[0], dp_(left)[1]) + min(dp_(right)[0], dp_(right)[1]) +1$​
         * $dp[1] = min(dp_(left)[0], dp_(left)[2] ) + min( min(dp_(right)[0], dp_(right)[2] ) $​
         * $dp[2] = min(dp_(left)[0]+dp_(right)[2] , dp_(left)[2]+dp_(right)[0])$​

         在递推公式的基础之上，进一步明确初始化条件，由于树形DP是由子节点到父节点的推导过程，即对于空节点(null)的情况，根据状态定义，空节点无法安装摄像头，**dp[0]=inf表示不合法（实际代码中为$Integer.MAX_VALUE/2$，防止加法溢出）**，并且空节点不需要被监控，因此dp[1]=dp[2]=0；则对于叶子节点。**将dp[0]定义为无穷大的主要目的是对于dp[2]若一个节点其没有子节点则dp[2]状态应该也是不合法的**。

         最后，整个方法的入口为 $dp(root)[3] = dfs(root)$，而root没有父亲节点，因此最后的返回值应该是 $min(dp[0], dp[2])$

   3. 代码：

      ```java
      public int minCameraCover(TreeNode root) {
          int[] res = dfs(root);
          return Math.min(res[0], res[2]);
      }
      
      public int[] dfs(TreeNode root){
          if(root == null){
              return new int[]{Integer.MAX_VALUE/2, 0, 0};
          }
          int[] l = dfs(root.left);
          int[] r = dfs(root.right);
          int self = Math.min(l[0], l[1]) + Math.min(r[0], r[1]) +1;
          int by_parent = Math.min(l[0], l[2]) + Math.min(r[0], r[2]);
          int by_children = Math.min(Math.min(l[0]+r[2], l[2]+r[0]), l[0]+r[0]);
          return new int[]{self, by_parent, by_children};
      }
      ```

   4. 进阶：

      * 如果将这道题设定为 在节点 $x$ 安装摄像头需要花费 $cost[x]$ ，求监控所有树的最小花费：本题求的是最小个数，其实就相当于是所有摄像头的安装费用相等且都是1，则若改成 $cost[x]$ ，则对应只需要将 $dp[0]$ 的状态转移方程中的 +1 改成 + $cost[x]$ 即可
      * 如果每个节点不止有两个子节点，而是有多个，应该如何化简：\



4. Leetcode 124 二叉树中的最大路径和

   1. 题目：二叉树中的 **路径** 被定义为一条节点序列，序列中每对相邻节点之间都存在一条边。同一个节点在一条路径序列中 **至多出现一次** 。该路径 **至少包含一个** 节点，且不一定经过根节点。**路径和** 是路径中各节点值的总和。给你一个二叉树的根节点 `root` ，返回其 **最大路径和** 。

   2. 范围：树中节点数目范围是 `[1, 3 * 104]`  `-1000 <= Node.val <= 1000`

   3. 思路：此题相较于树形dp，更类似于dfs，重点在于区分在递归与回溯的过程中不断判断最长的路径是否出现在当前子树中，并且区分最终结果与每层递归返回值之间的区别。

   4. 代码：注意如何在递归过程中处理root

      ```java
      int result = Integer.MIN_VALUE;
      
      public int maxPathSum(TreeNode root) {
          dfs(root);
          return result;
      }
      
      //返回当前子树中以root为起点的最大路径和
      //排除 a -> root -> b的情形，是以root为起点的路径
      public int dfs(TreeNode root){
          if(root == null){return Integer.MIN_VALUE;}
          //子树中包含root的路径一共有三种
          //1. root - left/right - ... 仅涉及一颗子树
          //2. .. - left - root - right - ... 涉及两颗子树
          //只有当子树对应的最大路径和为正数时才选择，否则不选择
          int left_max = Math.max(dfs(root.left), 0);
          int right_max = Math.max(dfs(root.right), 0);
          int child_max = Math.max(left_max, right_max);
          //情形1:以root为起点的线性最大值即为左右子树的最大值+root本身
          //需要注意的是：由于本题中含有负数，并且路径中至少包含一个节点即为root
          //此即为返回值，并且也需要判断是否能成为最值
          int tmp_max = root.val + child_max;
          result = Math.max(result, tmp_max);
          //情况3:判断是不是可能是最值，不返回
          result = Math.max(result, left_max + right_max + root.val);
          return tmp_max;
      }
      ```

   5. 相似题目：leetcode 543 二叉树的直径：同样是返回二叉树中以root为根的子树的最大深度，并在dfs过程中考虑以root为中转点的直径是否会是最大值。

      

   

