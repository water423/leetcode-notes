## 摩尔投票

1. 摩尔投票

   1. 作用：在O(1)空间复杂度内找到出现次数超过k次的元素

   2. 简单摩尔投票算法：

      1. 概述：在集合中寻找可能存在的多数元素，这一元素在输入的序列重复出现并占到了序列元素的一半以上；**在第一遍遍历之后应该再进行一个遍历以统计第一次算法遍历的结果出现次数，确定其是否为众数；如果一个序列中没有占到多数的元素，那么第一次的结果就可能是无效的随机元素。**

         * 定义一个变量 $x$ 来保存那个可能为主要元素的值， 用来 $cnt$ 记录该值的出现次数。然后在遍历数组 $nums$ 过程中执行如下逻辑：
         * 如果 $cnt = 0$ ：说明之前出现过的 $x$  已经被抵消完了，更新一下 $x$ 为当前值，出现次数为 ：`x = nums[i], cnt = 1`
         * 如果  $cnt != 0$ ：说明之前统计的 $cnt$ 还没被抵消完，这是根据 $nums[i] $与 $x$​ 是否相等进行计算即可：`cnt += nums[i] == x ? 1 : -1`
         * 再进行一次遍历，检查这个「可能」的主要元素 $x$​ 的出现次数是否超过总数一半

      2. 原理：

         1. 若记 **众数** 的票数为 +1 ，**非众数** 的票数为 −1 ，则一定有所有数字的 **票数和 >0 **。
         2. 若数组的前 a 个数字的 票数和 =0 ，则 数组剩余 (n−a)个数字的 票数和一定仍 >0，即后 (n−a) 个数字的众数仍为 x
         3. 利用此特性，每轮假设发生 **票数和 =0** 都可以 **缩小剩余数组区间** 。当遍历完成时，最后一轮假设的数字即为众数。

      3. 代码：

         ```java
         public int majorityElement(int[] nums) {
             int vote = 0; int x = -1;
             for(int i = 0; i < nums.length; i++){
                 if(vote == 0){
                     x = nums[i]; vote++;
                 }else{
                     if(nums[i] == x) vote++;
                     else vote--;
                 }
             }
             return x;
         }
         ```

   3. 进阶摩尔投票问题：**统计出现次数超过 n/k 的数**

      1. 概述：**出现次数超过 n/k  的数最多只有 k−1 个。否则必然违背「数总共只有 n 个」或者「当前统计的是出现次数超过 n/k 的数」的前提条件** ，当明确了符合要求的数的数量之后，可以使用有限变量来代表这 *k*−1 个候选数及其出现次数。然后使用「摩尔投票」的标准做法，在遍历数组时同时 check 这 k−1 个数，假设当前遍历到的元素为 x：

         * 如果 x 本身是候选者的话，则对其出现次数加一；
         * 如果 x 本身不是候选者，检查是否有候选者的出现次数为 0
           * 若有，则让 x 代替其成为候选者，并记录出现次数为 1；
           * 若无，则让所有候选者的出现次数减一。
         * 当处理完整个数组后，这 k−1 个数可能会被填满，但不一定都是符合出现次数超过 n/k 要求的。，需要进行二次遍历，来确定候选者是否符合要求，将符合要求的数加到答案

      2. 原理：

         **若存在出现次数超过 n/k 的数，最后必然会成为这 k−1 个候选者之一**。（反证法证明：若出现次数超过 n/k 的数 x 最终没有成为候选者则会违背题目中的条件）

         1. x从来没有成为过候选：在遍历 x 的过程中，必然有 k−1 个候选者被减了超过 n/k 次，假设当前 x 出现次数为 C，已知$ C>n/k$ ，此时总个数为 $(k−1)∗C+C=C∗k$ 
            再根据 $C>n/k$ ，可知 $C∗k>n$ ，而我们总共就只有 n  个数，因此该情况恒不成立。
         2. x成为过候选但是被淘汰了：说明发生了对 x 出现次数减一的动作（减到 0），每次的减一操作，意味着有其余的 k−2 个候选者的出现次数也发生了减一动作，加上本身被遍历到的当前数 num[i]（即一定要有n/k个没有出现过的元素），共有 k−1 个数字的和 x 被一同统计。也可以推导出被减去的数的总数大于n。

      3. 代码：
         ```java
         int k = 3;
         
         public List<Integer> majorityElement(int[] nums) {
             int n = nums.length;
             int[][] candidate = new int[k-1][2]; //k-1个候选 [0]为值 [1]为cnt
             for(int num : nums){
                 boolean isExist = false;
                 int index_of_zero = -1;
                 for(int i = 0; i < candidate.length; i++){
                     //检查是否出现过 如果出现过就+1
                     //如果没有出现过同时记录第一个cnt=0的元素位置
                     //规定次数一定要大于0的目的是用于初始化时保证第一个被加入的元素正确
                     if(candidate[i][0] == num && candidate[i][1] > 0){  
                         candidate[i][1]++;
                         isExist = true;
                         break;
                     }else if(candidate[i][1] == 0 && index_of_zero == -1){
                         index_of_zero = i;
                     }
                 }
                 //如果完全没有出现过则替换
                 if(!isExist){
                     if(index_of_zero == -1){ //且没有候选的次数为0，所有候选的次数--
                         for(int[] c : candidate){ c[1]--; }
                     }else{  //有候选 替换
                         candidate[index_of_zero][0] = num;
                         candidate[index_of_zero][1] = 1;
                     } 
                 }
             }
         
             //再次遍历 统计候选的出现次数是不是真的满足条件
             int[] cnt = new int[k-1]; 
             for(int num :  nums){
                 for(int i = 0; i < cnt.length; i++){
                     if(candidate[i][0] == num && candidate[i][1] > 0){
                         cnt[i]++;
                     }
                 }
             }
             List<Integer> res = new ArrayList<>();
             for(int i = 0; i < cnt.length; i++){
                 if(cnt[i] > n/k){
                     res.add(candidate[i][0]);
                 }
             }
         
             return res;
         }
         ```

         



